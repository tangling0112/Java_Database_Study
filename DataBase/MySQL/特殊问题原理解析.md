### 1 为什么只能在`ORDER BY`中使用别名,其他关键字的子句中无法使用别名?

### 2 为什么`ORDER BY`不能位于`WHERE`之前?

### 3 为什么`LIMIT`不能位于`ORDER BY`之前?

### 4 从`SELECT`语句的执行顺序来解释我们的聚合函数的特性

> **特性**
>
> - `GROUP BY`不能用在``WHERE``之前
> - `WHERE`子句中不能使用聚合函数
> - `GROUP BY`中指定的字段可以不是我们查询的字段

### 5 `COUNT(*)`与`COUNT(列名)`与`COUNT(1)`与`COUNT(Expression)`的区别

- `COUNT(*)`:该操作会直接统计我们查询得到的**最终虚拟数据表**中的记录的个数
- `COUNT(列名)`:该操作会统计我们查询得到的**最终虚拟数据表**中的对应字段不为`NULL`的记录的个数
- `COUNT(1)`:该操作效果等同于`COUNT(*)`
- `COUNT(2)`:该效果等同于`COUNT(*)*2`
- `COUNT(n)`:该效果等同于`COUNT(*)*n`
- `COUNT(字段1>50)`:该操作会统计我们查询得到的**最终虚拟数据表**中**字段$$1$$取值大于$$50$$**的记录的个数
- `COUNT(字段1>50 AND 字段2 <30)`:该操作会统计我们查询得到的**最终虚拟数据表**中**字段$$1$$取值大于$$50$$且字段$$2$$取值小于30**的记录的个数

### 6 在一个`SELECT`查询中`GROUP BY`不能出现在`WHERE`之前,那么如何对`GROUP BY`得到的数据进行过滤呢?

> 对``GROUP BY``后的虚拟数据表进行记录的过滤操作是借助`HAVING`关键字来进行的,当然其实我们还可以借助**子查询**的方式使用``WHERE``来完成这个过滤过程.

### 7 `MySQL`中`WHERE`与`HAVING`的不同

> 两者都是用于按条件过滤的,并且对于单表查询而言,两者底层十分相似,但是由于`SELECT`执行顺序问题导致了他们的一些不同.其区别有以下两个
>
> - ==**不同点1**==:`WHERE`由于`MySQL`的底层实现,其是一个用于遍历每一条记录的过滤条件,无法获得大于一条以上的记录的信息,因此`WHERE`子句中是**无法使用任何涉及到多个记录的同时操作的行为的**.而`HAVING`是必须与`GROUP BY`配合并紧跟`GROUP BY`语句的因此`HAVING`子句中**既可以使用单记录行为又可以使用多记录行为**
> - ==**不同点2**==:对于**关联查询**问题`WHERE`子句是先筛选再连接,而`HAVING`则是先连接再筛选,因此`WHERE`子句在关联查询上**性能优于**`HAVING`子句.**因此当我们使用到关联查询时,可以考虑通过子查询的方式将`HAVING`实现替换为`WHERE`实现以提高性能**
> - ==**补充**==:`HAVING`的过滤粒度为**分组**,而`WHERE`的过滤粒度为**记录**
>   - **过滤粒度为分组**:即其筛选的是以分组为单位的,如果对应的分组不符合`HAVING`子句筛选条件,或该分组中存在记录不符合`HAVING`子句筛选条件,那么其对应的那整个分组都会被剔除
>   - **过滤粒度为记录**:即其筛选是以记录为单位的,如果对应的记录不符合筛选条件,那么就会将该记录剔除

### 8 `MySQL`的`SELECT`语句的关键字的先后排列顺序的规定

#### **内连接**

```SQL
SELECT DISTINCT Table1.字段1,Table2.字段2
FROM Tabel1 
JOIN Table2
ON 连接条件
WHERE((过滤条件1 AND 过滤条件2) OR (NOT 过滤条件3)) 
GROUP BY Table1.字段3
HAVING 过滤条件
ORDER BY Table1.字段1 DESC
LIMIT 分页设置
```

##### 执行顺序

1. 执行两个表的内连接操作`JOIN`,得到两个表笛卡尔积后的**虚拟数据表1**
2. 对**虚拟数据表1**按照`ON`子句进行连接筛选,得到**虚拟数据表2**
3. 对**虚拟数据表2**执行`WHERE`子句指示的过滤操作(==过滤粒度为记录==)得到过滤后的**虚拟数据表3**
4. 对**虚拟数据表3**按照`GROUP BY`子句进行分组操作,得到**虚拟数据表4**
5. 对**虚拟数据表4**按照`HAVING`子句进行过滤操作(==过滤粒度为分组==),得到**虚拟数据表5**
6. 对**虚拟数据表5**按照`ORDER BY`子句进行排序操作,得到**虚拟数据表6**
7. 对**虚拟数据表6**进行`SELECT`子句查询操作,得到**虚拟数据表7**
8. 对**虚拟数据表7**进行`DISTINCT`去重操作,得到**虚拟数据表8**
9. 对**虚拟数据表8**进行`LIMIT`子句分页管理操作,得到**最终虚拟数据表9**
10. 将**虚拟数据表9**返回给用户

#### 外连接

```S\QL
SELECT Table1.字段1,Table2.字段2
FROM Tabel1 
LEFT JOIN Table2
ON 连接条件
WHERE((过滤条件1 AND 过滤条件2) OR (NOT 过滤条件3)) 
GROUP BY Table1.字段3
HAVING 过滤条件
ORDER BY Table1.字段1 DESC
LIMIT 分页设置
```

##### 执行顺序

1. 执行两个表的内连接操作`JOIN`,得到两个表笛卡尔积后的**虚拟数据表1**
2. 对**虚拟数据表1**按照`ON`子句进行连接筛选,得到**虚拟数据表2**
3. 对**虚拟数据表2**进行左表填充操作,得到**虚拟数据表3**
4. 对**虚拟数据表3**执行`WHERE`子句指示的过滤操作(==过滤粒度为记录==)得到过滤后的**虚拟数据表4**
5. 对**虚拟数据表4**按照`GROUP BY`子句进行分组操作,得到**虚拟数据表5**
6. 对**虚拟数据表5**按照`HAVING`子句进行过滤操作(==过滤粒度为分组==),得到**虚拟数据表6**
7. 对**虚拟数据表6**按照`ORDER BY`子句进行排序操作,得到**虚拟数据表7**
8. 对**虚拟数据表7**进行`SELECT`子句查询操作,得到**虚拟数据表8**
9. 对**虚拟数据表8**进行`DISTINCT`去重操作,得到**虚拟数据表9**
10. 对**虚拟数据表9**进行`LIMIT`子句分页管理操作,得到**最终虚拟数据表10**
11. 将**虚拟数据表10**返回给用户

### 9 `MySQL`的`SELECT`语句的关键字对应的操作的执行顺序

### 10 `MySQL`的`SELECT`语句的执行原理

### 11 如何对`GROUP BY`分组以粒度为记录进行过滤?

> **问题**:如果我们想分别筛选并剔除各个分组中一些不符合某种条件的记录,只保留各个分组中符合条件的记录.由于`HAVING`筛选的粒度是以**分组**为单位的,那么我们应该如何对`GROUP BY`分组实现这样的**记录粒度**的筛选呢?